var documenterSearchIndex = {"docs":
[{"location":"BoundingBoxes/#Bounding-Boxes-1","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"","category":"section"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"2-D bounding-boxes are built by:","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"BoundingBox(xmin,xmax,ymin,ymax)","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"to represent a 2D rectangular box whose sides are aligned with the coordinate axes and containing points of coordinates (x,y) such that xmin ≤ x ≤ xmax and ymin ≤ y ≤ ymax.","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"The type of the bounds, say T, can be explicitly specified:","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"BoundingBox{T}(xmin,xmax,ymin,ymax)","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"If unspecified, it is assumed to be he types of the bounds promoted to a common type.  The type of the bounds and can be retrieved by the eltype method.","category":"page"},{"location":"BoundingBoxes/#Aliases-1","page":"Bounding-Boxes","title":"Aliases","text":"","category":"section"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"Call:","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"using TwoDimensional.Suffixed","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"instead of:","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"using TwoDimensional","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"to have BoundingBox2D provided as an alias to TwoDimensional.BoundingBox.","category":"page"},{"location":"BoundingBoxes/#Construction-1","page":"Bounding-Boxes","title":"Construction","text":"","category":"section"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"The coordinates of a bounding-box can be specified by keywords:","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"BoundingBox(xmin=x0, ymin=y0, xmax=x1, ymax=y1)","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"There are no default values for keywords xmin, xmax, ymin and ymax so all must be specified.","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"A bounding-box can be constructed from a 4-tuple of coordinates and conversely:","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"BoundingBox((x0,x1,y0,y1))      # yields BoundingBox(x0,x1,y0,y1)\nTuple(BoundingBox(x0,x1,y0,y1)) # yields (x0,x1,y0,y1)","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"A bounding-box can be constructed from its first and last points (i.e. at the lower-left and upper right opposite corners) specified as instances of Point, of CartesianIndex{2} or of Tuple{Real,Real}:","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"BoundingBox(Point(x0,y0), Point(x1,y1))\nBoundingBox(CartesianIndex(x0,y0), CartesianIndex(x1,y1))\nBoundingBox((x0,y0), (x1,y1))","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"which all yield the same result:","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"BoundingBox(x0,x1,y0,y1)","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"Conversely, methods first(B) and last(B) respectively yield the lower left and upper right corners of the bounding-box B (as a Point instance):","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"first(BoundingBox(x0,x1,y0,y1)) # yields Point(x0,y0)\nlast(BoundingBox(x0,x1,y0,y1))  # yields Point(x1,y1)","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"Integer-valued unit-ranges can be specified to define a bounding-box.  For example:","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"BoundingBox(x0:x1, y0:y1)    # 2 unit-range\nBoundingBox((x0:x1, y0:y1))  # a 2-tuple of unit range","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"This makes possible writing:","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"BoundingBox(axes(A))","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"to get the bounding-box corresponding to all indices of array A.  Conversely:","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"axes(BoundingBox(x0,x1,y0,y1))","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"yields the axes of a bounding-box with integer coordinates, that is (x0:x1,y0:y1).  To get the k-th axis of a bounding-box B, call axes(B,k).","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"To loop over the Cartesian indices defined by a bounding-box B with integer coordinates, you can just write:","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"for I in CartesianIndices(B)\n   ...\nend","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"A bounding-box may also be constructed by applying a predicate function to the elements of a 2-dimensional array:","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"BoundingBox(f, A)","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"yields the bounding-box of all integer coordinates (x,y) such that f(A[x,y]) yields true.  If the elements of A are booleans (of type Bool), then BoundingBox(A) is equivalent to BoundingBox(identity,A).","category":"page"},{"location":"BoundingBoxes/#Fields-1","page":"Bounding-Boxes","title":"Fields","text":"","category":"section"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"The fields of a BoundingBox, say box, can be retrieved in different ways:","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"xmin = box.xmin\nxmax = box.xmax\nymin = box.ymin\nymax = box.ymax","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"or:","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"xmin = box[1]\nxmax = box[2]\nymin = box[3]\nymax = box[4]","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"or:","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"xmin, xmax, ymin, ymax = box","category":"page"},{"location":"BoundingBoxes/#Conversion-1","page":"Bounding-Boxes","title":"Conversion","text":"","category":"section"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"Coordinate type conversion, say to type T, is done by:","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"B = BoundingBox(x0,x1,y0,y1)\nBoundingBox{T}(B)\nconvert(BoundingBox{T}, B)\nT.(B)","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"The latter form involves broadcasting rules and may be a bit slower.","category":"page"},{"location":"BoundingBoxes/#Union-and-Intersection-of-Bounding-Boxes-1","page":"Bounding-Boxes","title":"Union and Intersection of Bounding-Boxes","text":"","category":"section"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"The union of bounding-boxes b1, b2, ... is given by one of:","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"B1 ∪ B2 ∪ ...\nunion(B1, B2, ...)","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"wich both yield the smallest bounding-box containing the bounding-boxes B1, B2, ...","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"The intersection of bounding-boxes B1, B2, ... is given by one of:","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"B1 ∩ B2 ∩ ...\nintersect(B1, B2, ...)","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"wich both yield the largest bounding-box contained into the bounding-boxes B1, B2, ...","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"The maximal or minimal bounding-box with coordinates of type T that can be constructed are respectively given by typemax(BoundingBox{T}) and typemin(BoundingBox{T}).  These can be useful to initiate a shrinking ar a growing bounding-box.  The call:","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"BoundingBox{T}(nothing)","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"yields the same result as typemin(BoundingBox{T}).","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"The method isempty(B) yields whether a bounding-box B is empty or not.","category":"page"},{"location":"BoundingBoxes/#Interior,-Exterior,-Nearest,-etc.-1","page":"Bounding-Boxes","title":"Interior, Exterior, Nearest, etc.","text":"","category":"section"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"Given the bounding-box B, interior(B) and exterior(B) respectively yield the largest interior and smallest exterior bounding-boxes with integer bounds.","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"round(B), round(T,B), or round(T,B,r) yield a bounding-box whose limits are those of the bounding-box B rounded to the nearest integral values with rounding mode r if specified (default is the same as round for a scalar).","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"center(B) yields the Point whose coordinates are the geometrical center of the bounding-box B.","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"area(B) yields the area of a bounding-box B.","category":"page"},{"location":"BoundingBoxes/#Arithmetic-and-Basic-Methods-1","page":"Bounding-Boxes","title":"Arithmetic and Basic Methods","text":"","category":"section"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"Adding or subtracting a scalar δ to a bounding-box B adds or removes a margin δ to the bounding-box B:","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"BoundingBox(x0,x1,y0,y1) + δ # yields BoundingBox(x0-δ,x1+δ,y0-δ,y1+δ)\nBoundingBox(x0,x1,y0,y1) - δ # yields BoundingBox(x0+δ,x1-δ,y0+δ,y1-δ)","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"Adding or subtracting a point P to a bounding-box B shifts the limits of the bounding-box B:","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"BoundingBox(x0,x1,y0,y1) + Point(x,y) # yields BoundingBox(x0+x,x1+x,y0+y,y1+y)","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"A bounding-box B can be negated:","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"-BoundingBox(x0,x1,y0,y1) # yields BoundingBox(-x1, -x0, -y1, -y0)","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"eltype(B) yields the type of the coordinates of a bounding-box B.","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"Basic methods size(B[,k]) and axes(B[,k]) can be applied to an integer-valued bounding-box B.  These two methods are type-stable: size(B) yields a 2-tuple of Int, size(B,k) yields an Int, axes(B) yields a 2-tuple of UnitRange{Int} and axes(B,k) yields a UnitRange{Int}.","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"The in (or operator ∈, obtained by \\in-tab) method let you check whether a point pnt is inside a bounding-box box:","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"pnt ∈ box","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"is a shortcut for:","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"(box.xmin ≤ pnt.x ≤ box.xmax) & (box.ymin ≤ pnt.y ≤ box.ymax)","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"The issubset (or operator ⊆, obtained by \\subseteq-tab) method can be used to check whether a bounding-box, say A, is inside another one, say B. That is issubset(A, B) or A ⊆ B is a shortcut for:","category":"page"},{"location":"BoundingBoxes/#","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"(isempty(A) | ((A.xmin ≥ B.xmin) & (A.xmax ≤ B.xmax) &\n               (A.ymin ≥ B.ymin) & (A.ymax ≤ B.ymax)))","category":"page"},{"location":"AffineTransforms/#Affine-Coordinate-Transforms-1","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"","category":"section"},{"location":"AffineTransforms/#","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"TwoDimensional provides types and methods to deal with 2-dimensional affine coordinate transforms.","category":"page"},{"location":"AffineTransforms/#","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"An affine 2D transform C is defined by 6 real coefficients, Cxx, Cxy, Cx, Cyx, Cyy and Cy.  Such a transform maps (x,y) as (xp,yp) given by:","category":"page"},{"location":"AffineTransforms/#","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"xp = Cxx*x + Cxy*y + Cx\nyp = Cyx*x + Cyy*y + Cy","category":"page"},{"location":"AffineTransforms/#","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"The immutable type AffineTransform{T} is used to store an affine 2D transform with coefficients of floating-point type T, it can be created by:","category":"page"},{"location":"AffineTransforms/#","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"I = AffineTransform{T}() # yields the identity with type T\nC = AffineTransform{T}(Cxx, Cxy, Cx, Cyx, Cyy, Cy)","category":"page"},{"location":"AffineTransforms/#","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"If the parameter T is omitted, it is guessed from the types of the coefficients.","category":"page"},{"location":"AffineTransforms/#Operations-with-affine-2D-transforms-1","page":"Affine Coordinate Transforms","title":"Operations with affine 2D transforms","text":"","category":"section"},{"location":"AffineTransforms/#","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"Many operations are available to manage or apply affine transforms.","category":"page"},{"location":"AffineTransforms/#Perform-a-coordinate-transformation-1","page":"Affine Coordinate Transforms","title":"Perform a coordinate transformation","text":"","category":"section"},{"location":"AffineTransforms/#","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"There are several possibilities to apply an affine transform A to coordinates (x,y):","category":"page"},{"location":"AffineTransforms/#","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"(xp, yp) = A(x,y)       # apply affine transform A to coordinates (x,y)\n(xp, yp) = A*(x,y)      # idem\n(xp, yp) = A(v)         # idem, with v = (x,y)\n(xp, yp) = A*v          # idem","category":"page"},{"location":"AffineTransforms/#","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"where x, y, xp and yp are reals while v = (x,y) is a 2-tuple of real coordinates.  Coordinates may also be specified as Point instances:","category":"page"},{"location":"AffineTransforms/#","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"A(Point(x,y)) -> Point(xp, yp)\nA*Point(x,y)  -> Point(xp, yp)","category":"page"},{"location":"AffineTransforms/#Reciprocal-transform-1","page":"Affine Coordinate Transforms","title":"Reciprocal transform","text":"","category":"section"},{"location":"AffineTransforms/#","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"The reciprocal transform of A is given by:","category":"page"},{"location":"AffineTransforms/#","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"B = inv(A)","category":"page"},{"location":"AffineTransforms/#Compose-coordinate-transformations-1","page":"Affine Coordinate Transforms","title":"Compose coordinate transformations","text":"","category":"section"},{"location":"AffineTransforms/#","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"To compose 2 (or more) transforms A and B, do one of:","category":"page"},{"location":"AffineTransforms/#","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"C = compose(A, B, ...)\nC = A∘B\nC = A*B\nC = A⋅B","category":"page"},{"location":"AffineTransforms/#","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"all these statements yields an object C which applies B then A.  Note that ∘ and ⋅ can be typed by \\\\circ<tab> and \\\\cdot<tab>.","category":"page"},{"location":"AffineTransforms/#","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"Left and right divisions respectively write:","category":"page"},{"location":"AffineTransforms/#","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"R = A/B   # right division, same as: R = compose(A, inv(B))\nL = A\\B   # left division, same as: L = compose(inv(A), B)","category":"page"},{"location":"AffineTransforms/#Translation-of-coordinates-1","page":"Affine Coordinate Transforms","title":"Translation of coordinates","text":"","category":"section"},{"location":"AffineTransforms/#","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"An operator B which which applies a translations by (x,y) after a coordinate transform A (possibly the identity) can be created by one of the following statements:","category":"page"},{"location":"AffineTransforms/#","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"B = translate(x, y, A)\nB = translate(v, A)\nB = v + A","category":"page"},{"location":"AffineTransforms/#","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"where v is a 2-tuple of coordinates, i.e. v = (x,y) or a Point, i.e. v = Point(x,y).","category":"page"},{"location":"AffineTransforms/#","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"To perform the translation before the coordinate transform A, do:","category":"page"},{"location":"AffineTransforms/#","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"B = translate(A, x, y)\nB = translate(A, v)\nB = A + v","category":"page"},{"location":"AffineTransforms/#Rotation-of-coordinates-1","page":"Affine Coordinate Transforms","title":"Rotation of coordinates","text":"","category":"section"},{"location":"AffineTransforms/#","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"B = rotate(θ, A)   # B = apply A then rotate by angle θ\nC = rotate(A, θ)   # C = rotate by angle θ then apply A","category":"page"},{"location":"AffineTransforms/#Scaling-of-coordinates-1","page":"Affine Coordinate Transforms","title":"Scaling of coordinates","text":"","category":"section"},{"location":"AffineTransforms/#","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"B = scale(ρ, A)    # B = apply A then scale by ρ\nB = ρ*A            # idem\nC = scale(A, ρ)    # C = scale by ρ then apply A\nC = A*ρ            # idem","category":"page"},{"location":"AffineTransforms/#Miscellaneous-1","page":"Affine Coordinate Transforms","title":"Miscellaneous","text":"","category":"section"},{"location":"AffineTransforms/#","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"det(A) returns the determinant of the linear part of the affine transform A.","category":"page"},{"location":"AffineTransforms/#","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"jacobian(A) returns the Jacobian of the affine transform A, that is the absolute value of the determinant of its linear part.","category":"page"},{"location":"AffineTransforms/#Type-conversion-1","page":"Affine Coordinate Transforms","title":"Type conversion","text":"","category":"section"},{"location":"AffineTransforms/#","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"As a general rule, the floating-point type T of an AffineTransform{T} is imposed for all operations and for the result.  The floating-point type of the composition of several coordinate transforms is the promoted type of the transforms which have been composed.","category":"page"},{"location":"AffineTransforms/#","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"The type of the coefficients of the affine transform A  is given by:","category":"page"},{"location":"AffineTransforms/#","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"eltype(A)","category":"page"},{"location":"AffineTransforms/#","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"To convert the floating-point type of the coefficients of A to be T, do one of:","category":"page"},{"location":"AffineTransforms/#","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"B = T.(A)\nB = AffineTransform{T}(A)\nB = convert(AffineTransform{T}, A)","category":"page"},{"location":"install/#Installation-1","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/#","page":"Installation","title":"Installation","text":"TwoDimensional is not yet an offical Julia package but it is easy to install it from Julia as explained here.","category":"page"},{"location":"install/#Using-the-package-manager-1","page":"Installation","title":"Using the package manager","text":"","category":"section"},{"location":"install/#","page":"Installation","title":"Installation","text":"At the REPL of Julia, hit the ] key to switch to the package manager REPL (you should get a ... pkg> prompt) and type:","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"pkg> add https://github.com/emmt/TwoDimensional.jl","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"where pkg> represents the package manager prompt and https protocol has been assumed; if ssh is more suitable for you, then type:","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"pkg> add git@github.com:emmt/TwoDimensional.jl","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"instead.  To check whether the TwoDimensional package works correctly, type:","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"pkg> test TwoDimensional","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"Later, to update to the last version (and run tests), you can type:","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"pkg> update TwoDimensional\npkg> build TwoDimensional\npkg> test TwoDimensional","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"If something goes wrong, it may be because you already have an old version of TwoDimensional.  Uninstall TwoDimensional as follows:","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"pkg> rm TwoDimensional\npkg> gc\npkg> add https://github.com/emmt/TwoDimensional.jl","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"before re-installing.","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"To revert to Julia's REPL, hit the Backspace key at the ... pkg> prompt.","category":"page"},{"location":"install/#Installation-in-scripts-1","page":"Installation","title":"Installation in scripts","text":"","category":"section"},{"location":"install/#","page":"Installation","title":"Installation","text":"To install TwoDimensional in a Julia script, write:","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"if VERSION >= v\"0.7.0-\"; using Pkg; end\nPkg.add(PackageSpec(url=\"https://github.com/emmt/TwoDimensional.jl\", rev=\"master\"));","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"or with url=\"git@github.com:emmt/TwoDimensional.jl\" if you want to use ssh.","category":"page"},{"location":"install/#","page":"Installation","title":"Installation","text":"This also works from the Julia REPL.","category":"page"},{"location":"reference/#Reference-1","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"The following summarizes the documentation of types and methods provided by the TwoDimensional package.  This information is also available from the REPL by typing ? followed by the name of a method or a type.","category":"page"},{"location":"reference/#Affine-2D-Coordinate-Transforms-1","page":"Reference","title":"Affine 2D Coordinate Transforms","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"AffineTransform\nscale\nrotate\ntranslate\njacobian\nintercept\ncompose","category":"page"},{"location":"reference/#TwoDimensional.AffineTransforms.AffineTransform","page":"Reference","title":"TwoDimensional.AffineTransforms.AffineTransform","text":"Affine 2D Transforms\n\nAn affine 2D transform A is defined by 6 real coefficients, Axx, Axy, Ax, Ayx, Ayy and Ay.  Such a transform maps (x,y) as (xp,yp) given by:\n\nxp = Axx*x + Axy*y + Ax\nyp = Ayx*x + Ayy*y + Ay\n\nThe immutable type AffineTransform is used to store an affine 2D transform A, it can be created by:\n\nI = AffineTransform{T}() # yields the identity with type T\nA = AffineTransform{T}(Axx, Axy, Ax, Ayx, Ayy, Ay)\n\nThe parameter T above is used to specify the floating-point type for the coefficients; if omitted it is guessed from the types of the coefficients.\n\nOperations with affine 2D transforms\n\nMany operations are available to manage or apply affine transforms:\n\n(xp, yp) = A(x,y)       # apply affine transform A to coordinates (x,y)\n(xp, yp) = A*(x,y)      # idem\n(xp, yp) = A(v)         # idem, with v = (x,y)\n(xp, yp) = A*v          # idem\n\nA(Point(x,y)) -> Point(xp, yp)\nA*Point(x,y)  -> Point(xp, yp)\n\nC = compose(A, B, ...)  # compose 2 (or more) transforms, C = apply B then A\nC = A∘B                 # idem\nC = A*B                 # idem\nC = A⋅B                 # idem\n\nB = translate(x, y, A)  # B = apply A then translate by (x,y)\nB = translate(v, A)     # idem with v = (x,y)\nB = v + A               # idem\n\nB = translate(A, x, y)  # B = translate by (x,y) then apply A\nB = translate(A, v)     # idem with v = (x,y)\nB = A + v               # idem\n\nB = rotate(θ, A)   # B = apply A then rotate by angle θ\nC = rotate(A, θ)   # C = rotate by angle θ then apply A\n\nB = scale(ρ, A)    # B = apply A then scale by ρ\nB = ρ*A            # idem\nC = scale(A, ρ)    # C = scale by ρ then apply A\nC = A*ρ            # idem\n\nB = inv(A)         # reciprocal coordinate transform\nC = A/B            # right division, same as: C = compose(A, inv(B))\nC = A\\B            # left division, same as: C = compose(inv(A), B)\n\n\"∘\" and \"⋅\" can be typed by \\circ<tab> and \\cdot<tab>.\n\nType conversion\n\nAs a general rule, the floating-point type T of an AffineTransform{T} is imposed for all operations and for the result.  The floating-point type of the composition of several coordinate transforms is the promoted type of the transforms which have been composed.\n\nCalling eltype(A) yields floating-point type of the coefficients of the 2D affine transform A.  To convert the floating-point type of the coefficients of A to be T, do one of:\n\nB = T.(A)\nB = AffineTransform{T}(A)\nB = convert(AffineTransform{T}, A)\n\n\n\n\n\n","category":"type"},{"location":"reference/#TwoDimensional.AffineTransforms.scale","page":"Reference","title":"TwoDimensional.AffineTransforms.scale","text":"Scaling an affine transform\n\nThere are two ways to combine a scaling by a factor ρ with an affine transform A.  Left-scaling as in:\n\nB = scale(ρ, A)\n\nresults in scaling the output of the transform; while right-scaling as in:\n\nC = scale(A, ρ)\n\nresults in scaling the input of the transform.  The above examples yield transforms which behave as:\n\nB(v) = ρ.*A(v)\nC(v) = A(ρ.*v)\n\nwhere v is any 2-element tuple.\n\nThe same results can be obtained with the * operator:\n\nB = ρ*A    # same as: B = scale(ρ, A)\nC = A*ρ    # same as: B = scale(A, ρ)\n\nSee also: AffineTransform, rotate, translate.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.AffineTransforms.rotate","page":"Reference","title":"TwoDimensional.AffineTransforms.rotate","text":"Rotating an affine transform\n\nThere are two ways to combine a rotation by angle θ (in radians counterclockwise) with an affine transform A.  Left-rotating as in:\n\nB = rotate(θ, A)\n\nresults in rotating the output of the transform; while right-rotating as in:\n\nC = rotate(A, θ)\n\nresults in rotating the input of the transform.  The above examples are similar to:\n\nB = R∘A\nC = A∘R\n\nwhere R implements rotation by angle θ around (0,0).\n\nSee also: AffineTransform, scale, translate.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.AffineTransforms.translate","page":"Reference","title":"TwoDimensional.AffineTransforms.translate","text":"Translating an affine transform\n\nAffine transforms can be letf- or right-translated.\n\ntranslate(x, y, A)\n\nor\n\ntranslate((x,y), A)\n\nyield an affine transform which translate the output of affine transform A by offsets x and y.\n\ntranslate(A, x, y)\n\nor\n\ntranslate(A, (x,y))\n\nyield an affine transform which translate the input of affine transform A by offsets x and y.\n\nThe same results can be obtained with the + operator:\n\nB = (x,y) + A    # same as: B = translate((x,y), A)\nB = A + (x,y)    # same as: B = translate(A, (x,y))\n\nSee also: AffineTransform, rotate, scale.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.AffineTransforms.jacobian","page":"Reference","title":"TwoDimensional.AffineTransforms.jacobian","text":"jacobian(A) returns the Jacobian of the affine transform A, that is the absolute value of the determinant of its linear part.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.AffineTransforms.intercept","page":"Reference","title":"TwoDimensional.AffineTransforms.intercept","text":"intercept(A) returns the tuple (x,y) such that A(x,y) = (0,0).\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.AffineTransforms.compose","page":"Reference","title":"TwoDimensional.AffineTransforms.compose","text":"compose(A,B) yields the affine transform which combines the two affine transforms A and B, that is the affine transform which applies B and then A.  Composition is accessible via: A∘B, A*B or A⋅B (\"∘\" and \"⋅\" can be typed by \\circ<tab> and \\cdot<tab>).\n\nIt is possible to compose more than two affine transforms.  For instance, compose(A,B,C) yields the affine transform which applies C then B, then A.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Points-1","page":"Reference","title":"Points","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"AbstractPoint\nPoint\nWeightedPoint\ndistance","category":"page"},{"location":"reference/#TwoDimensional.AbstractPoint","page":"Reference","title":"TwoDimensional.AbstractPoint","text":"AbstractPoint{T}\n\nis the abstract type of objects with at least 2 properties: x and y, their respective abscissa and ordinate, both of type T.\n\nSee also: Point, WeightedPoint.\n\n\n\n\n\n","category":"type"},{"location":"reference/#TwoDimensional.Point","page":"Reference","title":"TwoDimensional.Point","text":"Point(x,y)\n\nyields an instance of a 2D point of coordinates (x,y).\n\nA point may be multiplied or divided by a scalar to scale its coordinates.  The addition (resp. subtraction) of two points adds (resp. subtracts) their coordinates.\n\nCoordinates can be specified by keywords:\n\nPoint(x=xval, y=yval)\n\nThere are no default values for keywords x and y so both must be specified.\n\nThe coordinates of a Point, say pnt, can be retrieved as follows:\n\npnt.x  or  pnt[1]  ->  x\npnt.y  or  pnt[2]  ->  y\n\nor:\n\nx, y = pnt\n\nSee also: WeightedPoint, AbstractPoint.\n\n\n\n\n\n","category":"type"},{"location":"reference/#TwoDimensional.WeightedPoint","page":"Reference","title":"TwoDimensional.WeightedPoint","text":"WeightedPoint{T}(w,x,y)\n\nyields a weighted point which has 3 fields: w its weight, x its abscissa and y its ordinate, all of type T.  By convention w ≥ 0 but this is not checked for efficiency reasons.\n\nSee also: Point, AbstractPoint.\n\n\n\n\n\n","category":"type"},{"location":"reference/#TwoDimensional.distance","page":"Reference","title":"TwoDimensional.distance","text":"distance(A, B)\n\nyields the Euclidean distance between the 2 points A and B.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Bounding-Boxes-1","page":"Reference","title":"Bounding-Boxes","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"BoundingBox\narea\ncenter\ninterior\nexterior","category":"page"},{"location":"reference/#TwoDimensional.BoundingBox","page":"Reference","title":"TwoDimensional.BoundingBox","text":"BoundingBox(xmin,xmax,ymin,ymax)\n\nyields an instance of a 2D rectangular bounding-box whose sides are aligned with the coordinate axes and containing points of coordinates (x,y) such that xmin ≤ x ≤ xmax and ymin ≤ y ≤ ymax.  The box is empty if xmin > xmax or ymin > ymax.\n\nA bounding-box can be constructed from the first and last points (i.e. at the lower-left and upper right opposite corners) of the box:\n\nBoundingBox(P0::Point, P1::Point)\nBoundingBox(I0::CartesianIndex{2}, I1::CartesianIndex{2})\n\nCoordinates can be specified by keywords:\n\nBoundingBox(xmin=x0, ymin=y0, xmax=x1, ymax=y1)\n\nThere are no default values for keywords xmin, xmax, ymin and ymax so all must be specified.\n\nThe coordinates of a BoundingBox, say box, can be retrieved as follows:\n\nbox.xmin  or  box[1]  ->  xmin\nbox.xmax  or  box[2]  ->  xmax\nbox.ymin  or  box[3]  ->  ymin\nbox.ymax  or  box[4]  ->  ymax\n\nor:\n\nxmin, xmax, ymin, ymax = box\n\nSee also Point, interior, exterior.\n\n\n\n\n\n","category":"type"},{"location":"reference/#TwoDimensional.area","page":"Reference","title":"TwoDimensional.area","text":"area(B)\n\nyields the area of the bounding-box B.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.center","page":"Reference","title":"TwoDimensional.center","text":"center(B::BoundingBox) -> c::Point\n\nyields the central point of the bounding-box B.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.interior","page":"Reference","title":"TwoDimensional.interior","text":"interior([T,] B)\n\nyields the largest bounding-box with integer valued bounds and which is contained by the bounding-box B.  Optional argument T is to specify the type of the result or of the coordinates of the result which is the same as B by default.\n\nSee also: exterior, round.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.exterior","page":"Reference","title":"TwoDimensional.exterior","text":"exterior([T,] B)\n\nyields the smallest bounding-box with integer valued bounds and which contains the bounding-box B.  Optional argument T is to specify the type of the result or of the coordinates of the result which is the same as B by default.\n\nSee also: interior, round.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Methods-1","page":"Reference","title":"Methods","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"round(::Union{Point,BoundingBox})\nfloor(::Point)\nceil(::Point)","category":"page"},{"location":"reference/#Aliases-1","page":"Reference","title":"Aliases","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"AbstractPoint2D\nPoint2D\nWeightedPoint2D\nBoundingBox2D\nAffineTransform2D","category":"page"},{"location":"reference/#TwoDimensional.AbstractPoint2D","page":"Reference","title":"TwoDimensional.AbstractPoint2D","text":"AffineTransform{T} is an alias for TwoDimensional.AbstractPoint{T}.\n\n\n\n\n\n","category":"type"},{"location":"reference/#TwoDimensional.Point2D","page":"Reference","title":"TwoDimensional.Point2D","text":"Point2D{T} is an alias for TwoDimensional.Point{T}.\n\n\n\n\n\n","category":"type"},{"location":"reference/#TwoDimensional.WeightedPoint2D","page":"Reference","title":"TwoDimensional.WeightedPoint2D","text":"WeightedPoint2D{T} is an alias for TwoDimensional.WeightedPoint{T}.\n\n\n\n\n\n","category":"type"},{"location":"reference/#TwoDimensional.BoundingBox2D","page":"Reference","title":"TwoDimensional.BoundingBox2D","text":"BoundingBox2D{T} is an alias for TwoDimensional.BoundingBox{T}.\n\n\n\n\n\n","category":"type"},{"location":"reference/#TwoDimensional.AffineTransform2D","page":"Reference","title":"TwoDimensional.AffineTransform2D","text":"AffineTransform2D{T} is an alias for TwoDimensional.AffineTransform{T}.\n\n\n\n\n\n","category":"type"},{"location":"Points/#Points-1","page":"Points","title":"Points","text":"","category":"section"},{"location":"Points/#","page":"Points","title":"Points","text":"An object whose type is derived from AbstractPoint{T} (or AbstractPoint2D{T} if TwoDimensional.Suffixed is used instead of TwoDimensional) has 2-D coordinates: its abscissa and ordinate respectively named x and y.  The parameter T is the type of the coordinates and can be retrieved by the eltype method.","category":"page"},{"location":"Points/#Aliases-1","page":"Points","title":"Aliases","text":"","category":"section"},{"location":"Points/#","page":"Points","title":"Points","text":"Call:","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"using TwoDimensional.Suffixed","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"instead of:","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"using TwoDimensional","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"to have Point2D, WeightedPoint2D and AbstractPoint2D provided as respective aliases to TwoDimensional.Point TwoDimensional.WeightedPoint and TwoDimensional.AbstractPoint.","category":"page"},{"location":"Points/#Construction-1","page":"Points","title":"Construction","text":"","category":"section"},{"location":"Points/#","page":"Points","title":"Points","text":"The most simple concrete type is Point{T} constructed by:","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"Point(x,y)","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"where (x,y) are the coordinates of the point.  Weighted points of type WeightedPoint{T} associate a weight and coordinates:","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"WeightedPoint(w,x,y)","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"where (x,y) are the coordinates of the point and w its weight (nonnegative by convention).","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"Coordinates and weights can also be specified by keywords:","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"Point(x=xval, y=yval)","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"or","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"WeightedPoint(w=wgt, x=xval, y=yval)","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"There are no default values for keywords w, x and y so they must all be specified.","category":"page"},{"location":"Points/#Fields-1","page":"Points","title":"Fields","text":"","category":"section"},{"location":"Points/#","page":"Points","title":"Points","text":"The fields of a Point, say pnt, can be retrieved in different ways:","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"x = pnt.x\ny = pnt.y","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"or:","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"x = pnt[1]\ny = pnt[2]","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"or:","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"x, y = pnt","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"Similar rules apply for a WeightedPoint, say wpt:","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"w = wpt.w\nx = wpt.x\ny = wpt.y","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"or:","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"w = pnt[1]\nx = pnt[2]\ny = pnt[3]","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"or:","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"w, x, y = wpt","category":"page"},{"location":"Points/#Conversion-1","page":"Points","title":"Conversion","text":"","category":"section"},{"location":"Points/#","page":"Points","title":"Points","text":"Simple points can be constructed from a 2-tuple of coordinates or from an instance of 2-dimensional CartesianIndex:","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"v = (x,y)\nI = CartesianIndex(x,y)\nPoint(v)    # yields Point(x,y)\nPoint(I)    # yields Point(x,y)","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"and reciprocally, assuming P = Point(x,y):","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"Tuple(P)          # yields the 2-tuple (P.x, P.y)\nCartesianIndex(P) # yields CartesianIndex(P.x, P.y)","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"Coordinate type conversion, say to type T, for a point P = Point(x,y) is done by:","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"Point{T}(P)\nconvert(Point{T}, P)\nT.(P)","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"The latter form involves broadcasting rules and may be a bit slower.","category":"page"},{"location":"Points/#Operations-on-Points-1","page":"Points","title":"Operations on Points","text":"","category":"section"},{"location":"Points/#","page":"Points","title":"Points","text":"The addition (resp. subtraction) of two points adds (resp. subtracts) their coordinates:","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"Point(x1,y1) + Point(x2,y2)   # yields Point(x1+x2,y1+y2)\nPoint(x1,y1) - Point(x2,y2)   # yields Point(x1-x2,y1-y2)","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"Unary minus of a point negates its coordinates:","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"-Point(x,y)   # yields Point(-x,-y)","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"A point may be multiplied or divided by a scalar, say α, to scale its coordinates:","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"α*Point(x,y)  # yields Point(α*x,α*y)\nPoint(x,y)*α  # yields Point(α*x,α*y)\nα\\Point(x,y)  # yields Point((1/α)*x,(1/α)*y)\nPoint(x,y)/α  # yields Point((1/α)*x,(1/α)*y)","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"Taking the hypothenuse or the arctangent of a point P = Point(x,y) yield its distance to the origin O = Point(0,0) and the angle between OP and the abscissa axis:","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"hypot(Point(x,y))  # yields hypot(x, y)\natan(Point(x,y))   # yields atan(y, x)","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"The distance between two points is given by the distance method:","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"distance(Point(x1,y1),Point(x2,y2)  # yields hypot(x1-x2,y1-y2)","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"The nearest point to an instance obj of Point is given by:","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"round([T,] obj, [r::RoundingMode])","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"which rounds the coordinates of obj to the nearest integral value. Optional argument T is to specify the type of the result or the type of the coordinates of the result. Optional argument r is the rounding mode, the default is the same as round for a scalar value.","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"Similarly, floor([T,],P) and ceil([T,],P) yield the point with integer coordinates immediately (inclusively) before and after Point P.","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"A point can be clamped within the limits of a bounding-box:","category":"page"},{"location":"Points/#","page":"Points","title":"Points","text":"clamp(Point(-1.1, 6.3), BoundingBox(1:4,1:5)) # yields Point(1.0,5.0)","category":"page"},{"location":"#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"TwoDimensional is a Julia package which provides useful types and methods to define and manipulate 2-dimensional points, bounding boxes and affine coordinate transforms.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Other related packages:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"CoordinateTransformations","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"The source code of TwoDimensional is available on GitHub.","category":"page"},{"location":"#Exported-Types-1","page":"Introduction","title":"Exported Types","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"using TwoDimensional","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"gives you types AffineTransform{T}, Point{T} and BoundingBox{T} parameterized by the type T of their components (T must be floating point for AffineTransform{T}).","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"To avoid conflicts with other packages, you may use/import TwoDimensional.Suffixed which gives you types AffineTransform2D{T}, Point2D{T} and BoundingBox2D{T} instead, that is with suffix 2D.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"You can also fine tune what you want.  For instance:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"using TwoDimensional: AffineTransform, Point2D","category":"page"},{"location":"#Table-of-contents-1","page":"Introduction","title":"Table of contents","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Pages = [\"install.md\", \"AffineTransforms.md\",\n         \"Points.md\", \"BoundingBoxes.md\", \"reference.md\"]","category":"page"},{"location":"#Index-1","page":"Introduction","title":"Index","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"","category":"page"}]
}
