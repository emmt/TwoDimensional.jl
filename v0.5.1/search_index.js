var documenterSearchIndex = {"docs":
[{"location":"boxes/#Bounding-Boxes","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"","category":"section"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"Given the coordinates start=(xmin,ymin) and stop=(xmax,ymax) of the first and last 2-dimensional position in a rectangular region whose axes are aligned with the coordinate axes, a 2-D bounding-box representing this region is built by one of:","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"box = BoundingBox(start, stop)\nbox = BoundingBox(; start=..., stop=...)\nbox = BoundingBox((xmin,ymin), (xmax,ymax))\nbox = BoundingBox(; xmin=..., ymin=..., xmax=..., ymax=...)","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"All points of coordinates (x,y) such that xmin ≤ x ≤ xmax and ymin ≤ y ≤ ymax are considered as being part of the bounding-box. Hence, if xmin ≤ xmax and ymin ≤ ymax do not both hold, the box is empty as can be tested by isempty(box).","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"Arguments start and stop may also be two points (of type Point) or, for integer-valued coordinates, two Cartesian indices or two unit ranges:","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"box = BoundingBox(Point(xmin,ymin), Point(xmax,ymax))\nbox = BoundingBox(xmin:xmax, ymin:ymax)","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"As a convenience, all arguments can be given by a single tuple. For example:","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"box = BoundingBox((start, stop))\nbox = BoundingBox((xmin:xmax, ymin:ymax))","category":"page"},{"location":"boxes/#Coordinate-type","page":"Bounding-Boxes","title":"Coordinate type","text":"","category":"section"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"The coordinate type, say T, can be explicitly specified with the constructor, for example:","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"box = BoundingBox{T}(start, stop)","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"If T is unspecified, it is inferred from the coordinate type of the arguments promoted to a common type.","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"The coordinate type of a bounding-box can be retrieved by the coord_type and eltype methods.","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"Converting an existing bounding-box to another coordinate type can done by convert_coord_type.","category":"page"},{"location":"boxes/#Aliases","page":"Bounding-Boxes","title":"Aliases","text":"","category":"section"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"Call:","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"using TwoDimensional: BoundingBox2D","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"instead of:","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"using TwoDimensional","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"to have BoundingBox2D provided as an alias to TwoDimensional.BoundingBox and possibly avoid conflict with other packages.","category":"page"},{"location":"boxes/#Construction","page":"Bounding-Boxes","title":"Construction","text":"","category":"section"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"The coordinates of a bounding-box can be specified by keywords:","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"There are no default values for keywords xmin, xmax, ymin and ymax so all must be specified.","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"A bounding-box can be constructed from a 4-tuple of coordinates and conversely:","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"BoundingBox((x0,x1,y0,y1))      # yields BoundingBox(x0,x1,y0,y1)\nTuple(BoundingBox(x0,x1,y0,y1)) # yields (x0,x1,y0,y1)","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"A bounding-box can be constructed from its first and last points (i.e. at the lower-left and upper right opposite corners) specified as instances of Point, of CartesianIndex{2} or of Tuple{Real,Real}:","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"BoundingBox(Point(x0,y0), Point(x1,y1))\nBoundingBox(CartesianIndex(x0,y0), CartesianIndex(x1,y1))\nBoundingBox((x0,y0), (x1,y1))","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"which all yield the same result:","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"BoundingBox(x0,x1,y0,y1)","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"Conversely, methods first(B) and last(B) respectively yield the lower left and upper right corners of the bounding-box B (as a Point instance):","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"first(BoundingBox(x0,x1,y0,y1)) # yields Point(x0,y0)\nlast(BoundingBox(x0,x1,y0,y1))  # yields Point(x1,y1)","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"Integer-valued unit-ranges can be specified to define a bounding-box.  For example:","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"BoundingBox(x0:x1, y0:y1)    # 2 unit-range\nBoundingBox((x0:x1, y0:y1))  # a 2-tuple of unit range","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"This makes possible writing:","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"BoundingBox(axes(A))","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"to get the bounding-box corresponding to all indices of array A.  Conversely:","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"axes(BoundingBox(x0,x1,y0,y1))","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"yields the axes of a bounding-box with integer coordinates, that is (x0:x1,y0:y1).  To get the k-th axis of a bounding-box B, call axes(B,k).","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"To loop over the Cartesian indices defined by a bounding-box B with integer coordinates, you can just write:","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"for I in CartesianIndices(B)\n   ...\nend","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"A bounding-box may also be constructed by applying a predicate function to the elements of a 2-dimensional array:","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"BoundingBox(f, A)","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"yields the bounding-box of all integer coordinates (x,y) such that f(A[x,y]) yields true.  If the elements of A are booleans (of type Bool), then BoundingBox(A) is equivalent to BoundingBox(identity,A).","category":"page"},{"location":"boxes/#Fields","page":"Bounding-Boxes","title":"Fields","text":"","category":"section"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"The fields of a BoundingBox, say box, can be retrieved in different ways:","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"xmin = box.xmin\nxmax = box.xmax\nymin = box.ymin\nymax = box.ymax","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"or:","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"xmin = box[1]\nxmax = box[2]\nymin = box[3]\nymax = box[4]","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"or:","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"xmin, xmax, ymin, ymax = box","category":"page"},{"location":"boxes/#Conversion","page":"Bounding-Boxes","title":"Conversion","text":"","category":"section"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"Coordinate type conversion, say to type T, is done by:","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"B = BoundingBox(x0,x1,y0,y1)\nBoundingBox{T}(B)\nconvert(BoundingBox{T}, B)\nT.(B)","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"The latter form involves broadcasting rules and may be a bit slower.","category":"page"},{"location":"boxes/#Union-and-Intersection-of-Bounding-Boxes","page":"Bounding-Boxes","title":"Union and Intersection of Bounding-Boxes","text":"","category":"section"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"The union of bounding-boxes b1, b2, ... is given by one of:","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"B1 ∪ B2 ∪ ...\nunion(B1, B2, ...)","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"which both yield the largest bounding-box contained into the bounding-boxes B1, B2, ...","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"The intersection of bounding-boxes B1, B2, ... is given by one of:","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"B1 ∩ B2 ∩ ...\nintersect(B1, B2, ...)","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"which both yield the smallest bounding-box containing the bounding-boxes B1, B2, ...","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"The maximal or minimal bounding-box with coordinates of type T that can be constructed are respectively given by typemax(BoundingBox{T}) and typemin(BoundingBox{T}). These can be useful to initiate a shrinking or a growing bounding-box. The call:","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"BoundingBox{T}(nothing)","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"yields the same result as typemin(BoundingBox{T}).","category":"page"},{"location":"boxes/#Interior,-Exterior,-Nearest,-etc.","page":"Bounding-Boxes","title":"Interior, Exterior, Nearest, etc.","text":"","category":"section"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"Given the bounding-box B, interior(B) and exterior(B) respectively yield the largest interior and smallest exterior bounding-boxes with integer bounds.","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"round(B), round(T,B), or round(T,B,r) yield a bounding-box whose limits are those of the bounding-box B rounded to the nearest integral values of type T with rounding-mode r. Default type T is eltype(B) and default rounding-mode r is RoundingNearest.","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"center(B) yields the Point whose coordinates are the geometrical center of the bounding-box B.","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"area(B) yields the area of a bounding-box B.","category":"page"},{"location":"boxes/#Arithmetic-and-Basic-Methods","page":"Bounding-Boxes","title":"Arithmetic and Basic Methods","text":"","category":"section"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"Adding or subtracting a scalar δ to a bounding-box B adds or removes a margin δ to the bounding-box B:","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"BoundingBox((x0,y0),(x1,y1)) + δ -> BoundingBox((x0-δ,y0-δ),(x1+δ,y1+δ))\nBoundingBox((x0,y0),(x1,y1)) - δ -> BoundingBox((x0+δ,y0+δ),(x1-δ,y1-δ))","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"Adding or subtracting a point P to a bounding-box B shifts the limits of the bounding-box B:","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"BoundingBox((x0,y0),(x1,y1)) + Point(x,y) -> BoundingBox((x0+x,y0+y),(x1+x,y1+y))","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"A bounding-box B can be negated:","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"-BoundingBox((x0,y0),(x1,y1)) -> BoundingBox((-x1,-y1),(-x0,-y0))","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"eltype(B) yields the type of the coordinates of a bounding-box B.","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"Basic methods size(B[,k]) and axes(B[,k]) can be applied to an integer-valued bounding-box B.  These two methods are type-stable: size(B) yields a 2-tuple of Int, size(B,k) yields an Int, axes(B) yields a 2-tuple of UnitRange{Int} and axes(B,k) yields a UnitRange{Int}.","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"Method in and operator ∈, obtained by \\in-tab, yield whether a point pnt is inside a bounding-box box:","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"pnt ∈ box","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"is a shortcut for:","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"(box.xmin ≤ pnt.x ≤ box.xmax) & (box.ymin ≤ pnt.y ≤ box.ymax)","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"Method issubset or operator ⊆, obtained by \\subseteq-tab, yield whether a bounding-box, say A, is inside another one, say B. That is issubset(A, B) and A ⊆ B are shortcuts for:","category":"page"},{"location":"boxes/","page":"Bounding-Boxes","title":"Bounding-Boxes","text":"(isempty(A) | ((A.xmin ≥ B.xmin) & (A.xmax ≤ B.xmax) &\n               (A.ymin ≥ B.ymin) & (A.ymax ≤ B.ymax)))","category":"page"},{"location":"xforms/#Affine-Coordinate-Transforms","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"","category":"section"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"TwoDimensional provides types and methods to deal with 2-dimensional affine coordinate transforms.","category":"page"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"An affine 2D transform A is defined by 6 real coefficients, Axx, Axy, Ax, Ayx, Ayy and Ay. Such a transform maps (x,y) as (xp,yp) given by:","category":"page"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"xp = Axx*x + Axy*y + Ax\nyp = Ayx*x + Ayy*y + Ay","category":"page"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"coefficients Axx, Axy, Ayx, and Ayy are factors while coefficients Ax and Ay are offsets.","category":"page"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"The immutable type AffineTransform{T} is used to store an affine 2D transform with coefficients of floating-point type T, it can be created by:","category":"page"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"I = AffineTransform{T}() # yields the identity with type T\nA = AffineTransform{T}(Axx, Axy, Ax, Ayx, Ayy, Ay)","category":"page"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"If the parameter T is omitted, it is guessed from the types of the coefficients.","category":"page"},{"location":"xforms/#Operations-with-affine-2D-transforms","page":"Affine Coordinate Transforms","title":"Operations with affine 2D transforms","text":"","category":"section"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"Many operations are available to manage or apply affine transforms.","category":"page"},{"location":"xforms/#Perform-a-coordinate-transformation","page":"Affine Coordinate Transforms","title":"Perform a coordinate transformation","text":"","category":"section"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"There are several possibilities to apply an affine transform A to coordinates (x,y):","category":"page"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"(xp, yp) = A(x,y)       # apply affine transform A to coordinates (x,y)\n(xp, yp) = A*(x,y)      # idem\n(xp, yp) = A(v)         # idem, with v = (x,y)\n(xp, yp) = A*v          # idem","category":"page"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"where x, y, xp and yp are reals while v = (x,y) is a 2-tuple of real coordinates.  Coordinates may also be specified as Point instances:","category":"page"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"A(Point(x,y)) -> Point(xp, yp)\nA*Point(x,y)  -> Point(xp, yp)","category":"page"},{"location":"xforms/#Reciprocal-transform","page":"Affine Coordinate Transforms","title":"Reciprocal transform","text":"","category":"section"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"The reciprocal transform of A is given by:","category":"page"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"B = inv(A)","category":"page"},{"location":"xforms/#Compose-coordinate-transformations","page":"Affine Coordinate Transforms","title":"Compose coordinate transformations","text":"","category":"section"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"To compose 2 (or more) transforms A and B, do one of:","category":"page"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"C = compose(A, B, ...)\nC = A∘B\nC = A*B\nC = A⋅B","category":"page"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"all these statements yields an object C which applies B then A.  Note that ∘ and ⋅ can be typed by \\\\circ<tab> and \\\\cdot<tab>.","category":"page"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"Left and right \"divisions\" of affine tansforms respectively write:","category":"page"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"A/B -> A∘inv(B)\nA\\B -> inv(A)∘B","category":"page"},{"location":"xforms/#Translation-of-coordinates","page":"Affine Coordinate Transforms","title":"Translation of coordinates","text":"","category":"section"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"An operator B which which applies a translations by (x,y) after a coordinate transform A (possibly the identity) can be created by one of the following statements:","category":"page"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"B = translate(x, y, A)\nB = translate(pnt, A)\nB = pnt + A","category":"page"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"where pnt is a 2-tuple of coordinates, pnt = (x,y), a Point, pnt = Point(x,y), or 2-dimensional Cartesian index, CartesianIndex{2}(x,y).","category":"page"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"To perform the translation before the coordinate transform A, do:","category":"page"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"B = translate(A, x, y)\nB = translate(A, pnt)\nB = A + pnt","category":"page"},{"location":"xforms/#Rotating-an-affine-transform","page":"Affine Coordinate Transforms","title":"Rotating an affine transform","text":"","category":"section"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"There are two ways to combine a rotation by angle θ (in radians counterclockwise) with an affine transform A. Left-rotating as in:","category":"page"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"B = rotate(θ, A)","category":"page"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"results in rotating the output of the transform; while right-rotating as in:","category":"page"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"C = rotate(A, θ)","category":"page"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"results in rotating the input of the transform. The above examples are similar to:","category":"page"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"B = R∘A\nC = A∘R","category":"page"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"where R implements rotation by angle θ counterclockwise around the origin at coordinates (0,0). The rotation angle θ is assumed to be in radians if it has no units.","category":"page"},{"location":"xforms/#Scaling-of-coordinates","page":"Affine Coordinate Transforms","title":"Scaling of coordinates","text":"","category":"section"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"There are two ways to combine a scaling by a factor ρ with an affine transform A. Left-scaling as in:","category":"page"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"B = scale(ρ, A)\nB = ρ*A","category":"page"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"which yields B such that B(x,y) = ρ*A(x,y); or right-scaling as in:","category":"page"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"C = scale(A, ρ)\nC = A*ρ","category":"page"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"which yields C such that C(x,y) = A(ρ*x,ρ*y); or right-scaling as in:","category":"page"},{"location":"xforms/#Miscellaneous","page":"Affine Coordinate Transforms","title":"Miscellaneous","text":"","category":"section"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"det(A) returns the determinant of the linear part of the affine transform A.","category":"page"},{"location":"xforms/#Type-conversion","page":"Affine Coordinate Transforms","title":"Type conversion","text":"","category":"section"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"As a general rule, the floating-point type T of an AffineTransform{T} is imposed for all operations and for the result.  The floating-point type of the composition of several coordinate transforms is the promoted type of the transforms which have been composed.","category":"page"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"The type of the coefficients of the affine transform A  is given by:","category":"page"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"eltype(A)","category":"page"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"To convert the floating-point type of the coefficients of A to be T, do one of:","category":"page"},{"location":"xforms/","page":"Affine Coordinate Transforms","title":"Affine Coordinate Transforms","text":"B = T.(A)\nB = AffineTransform{T}(A)\nB = convert(AffineTransform{T}, A)","category":"page"},{"location":"install/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"TwoDimensional is an offical Julia package which can be installed in several ways as explained here.","category":"page"},{"location":"install/#Using-the-package-manager","page":"Installation","title":"Using the package manager","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"At the REPL of Julia, hit the ] key to switch to the package manager REPL (you should get a ... pkg> prompt) and type:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"pkg> add TwoDimensional","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"where pkg> represents the package manager prompt.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"To check whether the TwoDimensional package works correctly, type:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"pkg> test TwoDimensional","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Later, to update to the last version (and run tests), you can type:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"pkg> update TwoDimensional\npkg> build TwoDimensional\npkg> test TwoDimensional","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"If something goes wrong, it may be because you already have an old version of TwoDimensional. Uninstall TwoDimensional as follows:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"pkg> rm TwoDimensional\npkg> gc\npkg> add TwoDimensional","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"before re-installing.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"To revert to Julia's REPL, hit the Backspace key at the ... pkg> prompt.","category":"page"},{"location":"install/#Installation-in-scripts","page":"Installation","title":"Installation in scripts","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"To install TwoDimensional in a Julia script, write:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(PackageSpec(url=\"https://github.com/emmt/TwoDimensional.jl\", rev=\"master\"));","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"or with url=\"git@github.com:emmt/TwoDimensional.jl\" if you want to use ssh.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"This also works from the Julia REPL.","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"The following summarizes the documentation of types and methods provided by the TwoDimensional package.  This information is also available from the REPL by typing ? followed by the name of a method or a type.","category":"page"},{"location":"reference/#Points","page":"Reference","title":"Points","text":"","category":"section"},{"location":"reference/#TwoDimensional.AbstractPoint","page":"Reference","title":"TwoDimensional.AbstractPoint","text":"AbstractPoint{T} <: TwoDimensional.GeometricElement{T}\n\nis the abstract type of objects with at least 2 properties: x and y, their respective abscissa and ordinate, both of type T.\n\nSee also Point.\n\n\n\n\n\n","category":"type"},{"location":"reference/#TwoDimensional.AbstractPoint2D","page":"Reference","title":"TwoDimensional.AbstractPoint2D","text":"TwoDimensional.AbstractPoint2D{T}\n\nis an alias for TwoDimensional.AbstractPoint{T}.\n\n\n\n\n\n","category":"type"},{"location":"reference/#TwoDimensional.Point","page":"Reference","title":"TwoDimensional.Point","text":"pnt = Point{T}(x,y)\npnt = Point{T}((x,y))\npnt = Point{T}(; x=..., y=...)\npnt = Point{T}(; r=..., θ=...)\n\nconstruct a point given its Cartesian coordinates (x,y) (in the 3 first examples) or its polar coordinates (in the last example) with r the distance to the origin and θ the counterclockwise angle relative to x-axis. Parameter T is the type used to store coordinates, it may be omitted.\n\nNote that, in TwoDimensional, x and y respectively correspond to the 1st and 2nd dimensions of 2-dimensional arrays.\n\nA point may be multiplied or divided by a scalar to scale its coordinates. The addition (resp. subtraction) of two points adds (resp. subtracts) their coordinates.\n\nPoints have the following properties reflecting the keywords accepted by their constructor:\n\npnt.x  ->  x::T\npnt.y  ->  y::T\n\nPoints are indexable iterators:\n\nlength(pnt)     -> 2\nfirstindex(pnt) -> 1\nlastindex(pnt)  -> 2\npnt[1]          -> pnt.x\npnt[2]          -> pnt.y\nfirst(pnt)      -> pnt.x\nlast(pnt)       -> pnt.y\nTuple(pnt)      -> (pnt.x, pnt.y)\n\nThe coordinates of pnt can thus be retrieved by:\n\nx, y = pnt\n\nthe polar coordinates of the point can be retrieved by hypot(pnt) -> r, abs(pnt) -> r, or norm(pnt) -> r, and by atan(pnt) -> θ.\n\nSee also AbstractPoint, Rectangle, and BoundingBox.\n\n\n\n\n\n","category":"type"},{"location":"reference/#TwoDimensional.Point2D","page":"Reference","title":"TwoDimensional.Point2D","text":"TwoDimensional.Point2D{T}\n\nis an alias for TwoDimensional.Point{T}.\n\n\n\n\n\n","category":"type"},{"location":"reference/#TwoDimensional.PointLike","page":"Reference","title":"TwoDimensional.PointLike","text":"TwoDimensional.PointLike\n\nis the union of types of objects that can be converted into a TwoDimensional.Point.\n\nThe Point constructor can build an instance from any argument of these types. Accessors TwoDimensional.get_x and TwoDimensional.get_y may be used on objects of such type to retrieve their abscissa and ordinate.\n\n\n\n\n\n","category":"type"},{"location":"reference/#TwoDimensional.distance","page":"Reference","title":"TwoDimensional.distance","text":"distance(A, B)\n\nyields the Euclidean distance between the 2 points A and B.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.get_x","page":"Reference","title":"TwoDimensional.get_x","text":"TwoDimensional.get_x(pnt::PointLike) -> x\n\nyields the abscissa of point-like object pnt.\n\nSee also TwoDimensional.get_y, TwoDimensional.get_xy, and TwoDimensional.PointLike.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.get_xy","page":"Reference","title":"TwoDimensional.get_xy","text":"TwoDimensional.get_xy(pnt::PointLike) -> (x::T, y::T)\n\nyields a 2-tuple with the abscissa x and ordinate y of point-like object pnt. This is equivalent to, but more economical than, (get_x(pnt),get_y(pnt)).\n\nSee also TwoDimensional.get_x, TwoDimensional.get_y and TwoDimensional.PointLike.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.get_y","page":"Reference","title":"TwoDimensional.get_y","text":"TwoDimensional.get_y(pnt::PointLike) -> y\n\nyields the ordinate of point-like object pnt.\n\nSee also TwoDimensional.get_x, TwoDimensional.get_xy, and TwoDimensional.PointLike.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.point_type","page":"Reference","title":"TwoDimensional.point_type","text":"TwoDimensional.point_type(arg)\n\nyields the equivalent point type of arg.\n\nIf arg is a point-like object (or the type of such an object) the result is the point type of arg when converted to a Point.\n\nIf arg is a tuple of point-like objects, the result is the promoted type of the conversion of each arg to a Point.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LinearAlgebra.cross-Tuple{Point, Point}","page":"Reference","title":"LinearAlgebra.cross","text":"cross(a::Point, b::Point)\na * b\n\nyield the cross product (a.k.a. vector product or directed area product) of the two points a and b which is given by:\n\na.x*b.y - a.y*b.x\n\nnote: Note\nThe syntax a*b is deprecated.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearAlgebra.dot-Tuple{Point, Point}","page":"Reference","title":"LinearAlgebra.dot","text":"dot(a::Point, b::Point)\na ⋅ b\n\nyields the dot product (a.k.a. scalar product or inner product) of the two points a and b which is given by:\n\na.x*b.x + a.y*b.y\n\n\n\n\n\n","category":"method"},{"location":"reference/#Rectangles","page":"Reference","title":"Rectangles","text":"","category":"section"},{"location":"reference/#TwoDimensional.Rectangle","page":"Reference","title":"TwoDimensional.Rectangle","text":"rect = Rectangle{T}(start, stop)\nrect = Rectangle{T}((x0,y0), (x1,y1))\nrect = Rectangle{T}(; start=..., stop=...)\nrect = Rectangle{T}(; x0=..., x1=..., y0=..., y1=...)\n\nconstruct a rectangular rectangle with edges aligned with the Cartesian axes and given the coordinates of 2 opposite corners, start and stop, whose coordinates, (x0,y0) and (x1,y1), may be specified as points, as 2-tuples, as 2-dimensional Cartesian indices, or by keywords. Parameter T is the type used to store coordinates, it may be omitted.\n\nRectangles have the following properties reflecting the keywords accepted by their constructor:\n\nrect.x0  -> min(x0, x1)::T\nrect.x1  -> max(x0, x1)::T\nrect.y0  -> min(y0, y1)::T\nrect.y1  -> max(y0, y1)::T\nrect.start -> start::Point{T}\nrect.stop  -> stop::Point{T}\n\nNote that the coordinates are sorted. A rectangle is never empty and contains at least a single point.\n\nRectangles are indexable iterators:\n\nlength(rect)     -> 2\nfirstindex(rect) -> 1\nlastindex(rect)  -> 2\nrect[1]          -> rect.start\nrect[2]          -> rect.stop\nfirst(rect)      -> rect.start\nlast(rect)       -> rect.stop\nTuple(rect)      -> (rect.start, rect.stop)\n\nHence, the parameters of a rectangle can be retrieved by:\n\nstart, stop = rect\n(x0, y0), (x1, y1) = rect\n\nSee also Point, BoundingBox, interior, and exterior.\n\n\n\n\n\n","category":"type"},{"location":"reference/#TwoDimensional.Rectangle2D","page":"Reference","title":"TwoDimensional.Rectangle2D","text":"TwoDimensional.Rectangle2D{T}\n\nis an alias for TwoDimensional.Rectangle{T}.\n\n\n\n\n\n","category":"type"},{"location":"reference/#TwoDimensional.RectangleLike","page":"Reference","title":"TwoDimensional.RectangleLike","text":"TwoDimensional.RectangleLike\n\nis the union of types of objects that may be used to specify a rectangle in TwoDimensional package.\n\nThe Rectangle constructor can build an instance from any argument of these types.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Circles","page":"Reference","title":"Circles","text":"","category":"section"},{"location":"reference/#TwoDimensional.Circle","page":"Reference","title":"TwoDimensional.Circle","text":"circ = Circle{T}(center::Point, radius)\ncirc = Circle{T}((x, y), radius)\ncirc = Circle{T}(; center=..., radius=...)\n\nconstruct a circle of given center and radius or diameter. The center may be specified by its coordinates (x,y) along the Cartesian axes. Parameter T is the type used to store coordinates, it may be omitted.\n\nCircles have the following properties reflecting the keywords accepted by their constructor (diameter is provided for convenience):\n\ncirc.center   -> center::Point{T}\ncirc.radius   -> radius::T\ncirc.diameter -> 2*circ.radius\n\nCircles can be iterated to retrieve their center and their radius (in that order):\n\ncenter, radius = circ\n(x0, y0), radius = circ\n\nSee also Point, BoundingBox.\n\n\n\n\n\n","category":"type"},{"location":"reference/#TwoDimensional.Circle2D","page":"Reference","title":"TwoDimensional.Circle2D","text":"TwoDimensional.Circle2D{T}\n\nis an alias for TwoDimensional.Circle{T}.\n\n\n\n\n\n","category":"type"},{"location":"reference/#TwoDimensional.CircleLike","page":"Reference","title":"TwoDimensional.CircleLike","text":"TwoDimensional.CircleLike\n\nis the union of types of objects that may be used to specify a circle in TwoDimensional package.\n\nThe Circle constructor can build an instance from any argument of these types.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Polygons","page":"Reference","title":"Polygons","text":"","category":"section"},{"location":"reference/#TwoDimensional.Polygon","page":"Reference","title":"TwoDimensional.Polygon","text":"poly = Polygon{T}(pnts...)\npoly = Polygon{T}(pnts)\n\nconstruct a polygon with vertices given by point-like objects pnts... or vector or tuple of point-like objects pnts. Parameter T is the type of coordinates, if omitted, a common coordinate type is automatically inferred.\n\nThe vertices of a polygon may be stored as a tuple or as a vector. Call values(poly) to get the object backing the storage of the vertices of the polygon poly. The method Tuple(poly) yields a tuple of the vertices of poly. The method vec(poly) yields a vector of the vertices of the polygon which may be shared with poly. Call collect(poly) to make an independent copy of the vector of vertices.\n\nVertices are directly accessible by indexing the polygon object:\n\nlength(poly)     # number of vertices\nfirstindex(poly) # index of first vertex\nlastindex(poly)  # index of last vertex\npoly[i]          # i-th vertex (a point)\nfirst(poly)      # first vertex\nlast(poly)       # last vertex\nvalues(poly)     # vertices stored by `poly`\nvec(poly)        # vector of vertices\nVector(poly)     # vector of vertices\nTuple(poly)      # tuple of vertices\n\nSee also Point, TwoDimensional.vertices, and BoundingBox.\n\nwarning: Warning\nPolygons with a large number of vertices should preferably be created using a vector, not a tuple, of vertices.\n\n\n\n\n\n","category":"type"},{"location":"reference/#TwoDimensional.Polygon2D","page":"Reference","title":"TwoDimensional.Polygon2D","text":"TwoDimensional.Polygon2D{T}\n\nis an alias for TwoDimensional.Polygon{T}.\n\n\n\n\n\n","category":"type"},{"location":"reference/#TwoDimensional.PolygonLike","page":"Reference","title":"TwoDimensional.PolygonLike","text":"TwoDimensional.PolygonLike\n\nis the union of types of objects that can be converted into a TwoDimensional.Polygon. These are tuples or vectors of point-like objects.\n\nThe Polygon constructor can build an instance from any argument of these types. Accessors TwoDimensional.get_x and TwoDimensional.get_y may be used on objects of such type to retrieve their abscissa and ordinate.\n\n\n\n\n\n","category":"type"},{"location":"reference/#TwoDimensional.cross3","page":"Reference","title":"TwoDimensional.cross3","text":"TwoDimensional.cross3(A::Point, B::Point, C::Point) -> val\n\nyields the cross product of vector AB by vector AC.\n\nThe returned value can be used to determine the position of point C relatively to the infinite line defined by (A,B):\n\nif val > 0, then C is left of the line through A and B;\nif val = 0, then C is on the line through A and B;\nif val < 0, then C is right of the line through A and B.\n\nSee: Algorithm 1 \"Area of Triangles and Polygons\"\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.crossing_number_test","page":"Reference","title":"TwoDimensional.crossing_number_test","text":"TwoDimensional.crossing_number_test(P::Point, V) -> bool\n\nyields whether point P is inside the polygon defined by vertices V according to the crossing number method by Franklin (2000). V is a tuple or a vector of points.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.winding_number_test","page":"Reference","title":"TwoDimensional.winding_number_test","text":"TwoDimensional.winding_number_test(P::Point, V) -> bool\n\nyields whether point P is inside the polygon defined by vertices V according to the winding number method by Dan Sunday (\"Inclusion of a Point in a Polygon\", 2001). V is a tuple or a vector of points.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Bounding-Boxes","page":"Reference","title":"Bounding-Boxes","text":"","category":"section"},{"location":"reference/#TwoDimensional.BoundingBox","page":"Reference","title":"TwoDimensional.BoundingBox","text":"box = BoundingBox{T}(start, stop)\nbox = BoundingBox{T}((xmin,ymin), (xmax,ymax))\nbox = BoundingBox{T}(; start=..., stop=...)\nbox = BoundingBox{T}(; xmin=..., xmax=..., ymin=..., ymax=...)\n\nconstruct a rectangular bounding-box with edges aligned with the Cartesian axes and given the coordinates of 2 opposite corners, start and stop, whose coordinates, (xmin,ymin) and (xmax,ymax), may be specified as points, as 2-tuples, as 2-dimensional Cartesian indices, or by keywords. Parameter T is the type used to store coordinates, it may be omitted.\n\nAnother possibility is:\n\nBoundingBox{T}()\n\nto build an empty bounding-box for coordinate type T.\n\nBounding-boxes have the following properties reflecting the keywords accepted by their constructor:\n\nbox.xmin  -> xmin::T\nbox.xmax  -> xmax::T\nbox.ymin  -> ymin::T\nbox.ymax  -> ymax::T\nbox.start -> start::Point{T}\nbox.stop  -> stop::Point{T}\n\nA bounding-box is assumed to contain all points of coordinates (x,y) such that xmin ≤ x ≤ xmax and ymin ≤ y ≤ ymax. If xmin > xmax or ymin > ymax, the bounding-box is considered as empty. This can be checked with isempty(box).\n\nBoxes are used to represent grid cells and bounding-boxes of other geometric shape. Use TwoDimensional.Rectangle if you want to define rectangular masks.\n\nBounding-boxes are indexable iterators:\n\nlength(box)     -> 2\nfirstindex(box) -> 1\nlastindex(box)  -> 2\nbox[1]          -> box.start\nbox[2]          -> box.stop\nfirst(box)      -> box.start\nlast(box)       -> box.stop\nTuple(box)      -> (box.start, box.stop)\n\nHence, the parameters of a bounding-box can be retrieved by:\n\nstart, stop = box\n(xmin, ymin), (xmax, ymax) = box\n\nSee also Point, Rectangle, interior, and exterior.\n\n\n\n\n\nBoundingBox{T}(obj)\n\nyields the bounding-box of the geometric object obj. If the coordinate type T is not provided, T = coord_type(obj) is assumed.\n\nThis can be used to compute the union or the intersection of the bounding-boxes of objects:\n\nmapreduce(BoundingBox, ∪, (obj1, obj2, obj3, ...))\nmapreduce(BoundingBox, ∩, [obj1, obj2, obj3, ...])\n\n\n\n\n\nBoundingBox(f, A::AbstractMatrix)\n\nyields the minimal bounding-box of the entries of A such that f(A[i,j]) is true. This can be used to extract this rectangular region:\n\nA[BoundingBox(f, A)]\n\nIf A is a matrix of Booleans, f is assumed to be the identity if not specified.\n\n\n\n\n\n","category":"type"},{"location":"reference/#TwoDimensional.BoundingBox2D","page":"Reference","title":"TwoDimensional.BoundingBox2D","text":"TwoDimensional.BoundingBox2D{T}\n\nis an alias for TwoDimensional.BoundingBox{T}.\n\n\n\n\n\n","category":"type"},{"location":"reference/#TwoDimensional.BoundingBoxLike","page":"Reference","title":"TwoDimensional.BoundingBoxLike","text":"TwoDimensional.BoundingBoxLike\n\nis the union of types of objects that may be used to specify a bounding-box in TwoDimensional package.\n\nThe BoundingBox constructor can build an instance from any argument of these types.\n\n\n\n\n\n","category":"type"},{"location":"reference/#TwoDimensional.interior","page":"Reference","title":"TwoDimensional.interior","text":"interior([T,] box)\n\nyields the largest bounding-box with integer valued bounds and which is contained by the bounding-box box. Optional argument T is to specify the type of the result or the type of the coordinates of the result which is the same as box by default.\n\nSee also exterior, ceil and floor.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.exterior","page":"Reference","title":"TwoDimensional.exterior","text":"exterior([T,] box)\n\nyields the smallest bounding-box with integer valued bounds and which contains the bounding-box box. Optional argument T is to specify the type of the result or the type of the coordinates of the result which is the same as box by default.\n\nSee also interior, ceil and floor.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.grow","page":"Reference","title":"TwoDimensional.grow","text":"TwoDimensional.grow(box, dx, dy=dx)\n\nyields a new bounding-box object corresponding to the input box object with 1st and 2nd dimensions respectively grown by dx and dy.\n\nNote that the algebraic (not absolute) values of dx and dy are applied. Hence, if dx and dy are both negative, the bounding-box is effectively shrunk by abs(dx) and abs(dy).\n\nSee also TwoDimensional.shrink.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.shrink","page":"Reference","title":"TwoDimensional.shrink","text":"TwoDimensional.shrink(box, dx, dy=dx)\n\nyields a new bounding-box object corresponding to the input box object with 1st and 2nd dimensions respectively shrunk by dx and dy.\n\nNote that the algebraic (not absolute) values are applied. Hence, if dx and dy are both negative, the bounding-box is effectively grown by abs(dx) and abs(dy).\n\nSee also TwoDimensional.grow.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Coordinate-Type","page":"Reference","title":"Coordinate Type","text":"","category":"section"},{"location":"reference/#TwoDimensional.coord_type","page":"Reference","title":"TwoDimensional.coord_type","text":"coord_type(A) -> T\n\nyields the coordinate type of a geometrical object or of its type. With several arguments:\n\ncoord_type(A...) -> T\n\nor if single argument a tuple or a vector of geometrical objects, the promoted coordinate type is returned.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.convert_coord_type","page":"Reference","title":"TwoDimensional.convert_coord_type","text":"convert_coord_type(T::Type, obj::GeometricObject)\nGeometricObject{T}(obj)\n\nconvert the coordinate type of a geometrical object obj to T. If the coordinate type of obj is already T, obj itself is returned.\n\n\n\n\n\nconvert_coord_type(T::Type, objs::GeometricObject...) -> objs′\n\nyields the tuple of geometric objects objs... converted to the coordinate type T.\n\n\n\n\n\nconvert_coord_type(T::Type) -> f\n\nyields a callable object f such that f(x) is equivalent to convert_coord_type(T, x).\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.promote_coord_type","page":"Reference","title":"TwoDimensional.promote_coord_type","text":"promote_coord_type(objs...)\n\nconverts all arguments objs... to a common coordinate type and return them as a tuple.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Affine-2D-Coordinate-Transforms","page":"Reference","title":"Affine 2D Coordinate Transforms","text":"","category":"section"},{"location":"reference/#TwoDimensional.AffineTransform","page":"Reference","title":"TwoDimensional.AffineTransform","text":"AffineTransform(Axx, Axy, Ax, Ayx, Ayy, Ay) -> A\n\nyields a callable object implementing a 2-dimensional affine transform such that:\n\nA(x, y) -> (Axx*x + Axy*y + Ax, Ayx*x + Ayy*y + Ay)\nA((x, y)) -> (Axx*x + Axy*y + Ax, Ayx*x + Ayy*y + Ay)\nA(pnt::Point) -> Point(A(pnt.x, pnt.y))\nA(idx::CartesianIndex{2}) -> Point(A(idx[1], idx[2]))\n\nThe constructor optionally takes one or three parameters:\n\nAffineTransform{T}(Axx, Axy, Ax, Ayx, Ayy, Ay)\nAffineTransform{T,R,S}(Axx, Axy, Ax, Ayx, Ayy, Ay)\n\nwhere T is the concrete floating-point type of the coefficients, R is the type for storing the factors Axx, Axy, Ayx, and Ayy, and S is the type for storing the offsets Ax and Ay. The bare type of R and S must be T but they may have units.\n\nChanging the floating-point type of an existing 2-dimensional affine transform A can be done by one of:\n\nB = AffineTransform{T}(A)\nB = convert(AffineTransform{T}, A)\nB = convert_bare_type(T, A)\nB = convert_real_type(T, A)\nB = convert_floating_point_type(T, A)\n\nthe 3 last assume using TypeUtils. Using TypeUtils API, the floating-point type T can be retrieved by either of bare_type(A), realtype(A), orfloatingpoint_type(A)withA` a 2-dimensional affine transform instance or type.\n\nIf T is floating-point, changing the precision of the affine transform A while keeping their units can also be done by:\n\nB = adapt_precision(T, A)\n\nApplying the 2-dimensional affine transform A can be done by:\n\n(xp, yp) = A(x,y)       # apply affine transform A to coordinates (x,y)\n(xp, yp) = A*(x,y)      # idem\n(xp, yp) = A((x,y))     # idem\n\nA(Point(x,y)) -> Point(xp, yp)\nA*Point(x,y)  -> Point(xp, yp)\n\nC = compose(A, B, ...)  # compose 2 (or more) transforms, apply C = apply B then A\nC = A∘B                 # compose A and B\nC = A*B                 # idem\n\nB = translate(x, y, A)  # B = apply A then translate by (x,y)\nB = translate(pnt, A)   # idem with pnt = (x,y)\nB = pnt + A             # idem\n\nB = translate(A, x, y)  # B = translate by (x,y) then apply A\nB = translate(A, pnt)   # idem with pnt = (x,y)\nB = A + pnt             # idem\n\nB = rotate(θ, A)   # B = apply A then rotate by angle θ\nC = rotate(A, θ)   # C = rotate by angle θ then apply A\n\nB = scale(ρ, A)    # B = apply A then scale by ρ\nB = ρ*A            # idem\nC = scale(A, ρ)    # C = scale by ρ then apply A\nC = A*ρ            # idem\n\nB = inv(A)         # reciprocal coordinate transform\nC = A/B            # right division, same as: C = A ∘ inv(B)\nC = A\\B            # left division, same as: C = inv(A) ∘ B\n\n\"∘\" can be typed by \\circ<tab>.\n\n\n\n\n\nAffineTransform() -> Id\nAffineTransform{T}() -> Id\nAffineTransform{T,R,S}() -> Id\n\nyields a 2-dimensional affine transform corresponding to the identity (up to possible change of type and units). Parameter T is the floating-point type of the coefficients (Float64 by default). Parameters R and S are the types of the factors and of the offsets (by default both are assumed to be T). These are shortcuts to:\n\n AffineTransform(oneunit(R),zero(R),zero(S), zero(R),oneunit(R),zero(S))\n\n\n\n\n\n","category":"type"},{"location":"reference/#TwoDimensional.AffineTransform2D","page":"Reference","title":"TwoDimensional.AffineTransform2D","text":"TwoDimensional.AffineTransform2D{T,R,S}\n\nis an alias for TwoDimensional.AffineTransform{T,R,S}.\n\n\n\n\n\n","category":"type"},{"location":"reference/#TwoDimensional.compose","page":"Reference","title":"TwoDimensional.compose","text":"TwoDimensional.compose(A::AffineTransform, B::AffineTransform)\n\nyields the affine transform which combines the two affine transforms A and B, that is the affine transform which applies B and then A. Composition is accessible via: A*B or A∘B (\"∘\" can be typed by \\circ<tab>).\n\nIt is possible to compose more than two affine transforms. For instance, compose(A,B,C) yields the affine transform which applies C then B, then A.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.factors_type","page":"Reference","title":"TwoDimensional.factors_type","text":"TwoDimensional.factors_type(A) -> R\nTwoDimensional.factors_type(typeof(A)) -> R\n\nyield the type of the factors of the 2-dimensional affine transform A. The factors of A are the coefficients A.xx, A,xy, A.yx, and A.yy.\n\nSee also: offsets_type.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.offsets_type","page":"Reference","title":"TwoDimensional.offsets_type","text":"TwoDimensional.offsets_type(A) -> R\nTwoDimensional.offsets_type(typeof(A)) -> R\n\nyield the type of the offsets of the 2-dimensional affine transform A. The offsets of A are the coefficients A.x and A.y.\n\nSee also: factors_type.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.rotate","page":"Reference","title":"TwoDimensional.rotate","text":"B = rotate(θ, A)\nC = rotate(A, θ)\n\nyield 2-dmensional affine transforms B and C such that:\n\nB(x,y) = (R∘A)(x,y) = R(A(x,y))\nC(x,y) = (A∘R)(x,y) = A(R(x,y))\n\nwhere R implements rotation by angle θ counterclockwise around the origin at coordinates (0,0). The rotation angle θ is assumed to be in radians if it has no units.\n\nSee also: AffineTransform, scale, translate.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.scale","page":"Reference","title":"TwoDimensional.scale","text":"B = scale(ρ, A)\nB = ρ*A\nC = scale(A, ρ)\nC = A*ρ\n\nyield 2-dimensional affine transforms B and C such that:\n\nB(x,y) -> ρ*A(x,y)\nC(x,y) -> A(ρ*x,ρ*y)\n\nSee also: AffineTransform, rotate, translate.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.translate","page":"Reference","title":"TwoDimensional.translate","text":"B = translate(x, y, A)\nB = translate((x,y), A)\nB = translate(pnt, A)\nB = (x,y) + A\nB = pnt + A\n\nperform a left-translation of the 2-dimensional affine transform A. Applying B yields the same result as if coordinates (x,y) are added to the output of A. Here, pnt = Point(x,y) or pnt = CartesianIndex(x,y).\n\nC = translate(A, x, y)\nC = translate(A, (x,y))\nC = translate(A, pnt)\nC = A + (x,y)\nC = A + pnt\n\nperform a right-translation of the 2-dimensional affine transform A. Applying B yields the same result as if coordinates (x,y) are added to the input of A.\n\nSee also: AffineTransform, rotate, scale.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.ldiv","page":"Reference","title":"TwoDimensional.ldiv","text":"A\\B -> inv(A) ∘ B\nTwoDimensional.ldiv(A::AffineTransform, B::AffineTransform) -> inv(A) ∘ B\n\nyield the \"left division\" of the affine transform A by the affine transform B.\n\nIt is an abuse of notation to have A\\B being a shortcut to inv(A) ∘ B but this is in-line with the overloading of * such that A * B -> A ∘ B. This function is motivated by the fact that it takes only 29 flops whereas inv(A) ∘ B takes 37 flops (17 flops for inv and 20 flops for ∘).\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.rdiv","page":"Reference","title":"TwoDimensional.rdiv","text":"A/B -> A ∘ inv(B)\nTwoDimensional.rdiv(A::AffineTransform, B::AffineTransform) -> A ∘ inv(B)\n\nyield the \"right division\" of the affine transform A by the affine transform B.\n\nIt is an abuse of notation to have A/B being a shortcut to A ∘ inv(B) but this is in-line with the overloading of * such that A * B -> A ∘ B. This function is motivated by the fact that it takes only 29 flops whereas inv(A) ∘ B takes 37 flops (17 flops for inv and 20 flops for ∘).\n\n\n\n\n\n","category":"function"},{"location":"reference/#Masks","page":"Reference","title":"Masks","text":"","category":"section"},{"location":"reference/#TwoDimensional.Mask","page":"Reference","title":"TwoDimensional.Mask","text":"TwoDimensional.Mask(elems...)\nTwoDimensional.Mask{T}(elems...)\n\nbuild a composite mask consisting in the ordered list of mask elements elems.... Optional type parameter T is the coordinate type of the masks elements. All mask elements are converted as needed to have this coordinate type. If T is not specified, it is inferred by promoting the coordinate types of the mask elements.\n\nA mask can be moved, scaled, rotated, etc., the coordinate type of its elements may be converted to another type.\n\nwarning: Warning\nMasks with a large number of elements should preferably be created with a vector, not a tuple, of mask elements.\n\n\n\n\n\n","category":"type"},{"location":"reference/#TwoDimensional.MaskElement","page":"Reference","title":"TwoDimensional.MaskElement","text":"TwoDimensional.MaskElement(shape::ShapeElement; opaque::Bool)\n\nbuilds a simple mask whose boundaries are defined by shape and which is opaque (i.e., an obscuration) if opaque is true and transparent (i.e., an aperture) otherwise.\n\n\n\n\n\n","category":"type"},{"location":"reference/#TwoDimensional.MaskElement2D","page":"Reference","title":"TwoDimensional.MaskElement2D","text":"TwoDimensional.MaskElement2D{T,S}\n\nis an alias for TwoDimensional.MaskElement{T,S}. T is the coordinate type, S is the type of the elementary geometrical object defining the shape of the mask.\n\n\n\n\n\n","category":"type"},{"location":"reference/#TwoDimensional.Overlap","page":"Reference","title":"TwoDimensional.Overlap","text":"TwoDimensional.Overlap(pxl, obj)\n\nyields the overlapping of pixel pxl with shape object obj. pxl may be a point, a bounding-box, or a rectangle. Returned value is:\n\nINSIDE if pxl is fully inside the boundaries of obj;\nOUTSIDE if pxl is fully outside the boundaries of obj;\nPARTIAL if pxl straddles some boundaries of obj.\n\n\n\n\n\n","category":"type"},{"location":"reference/#TwoDimensional.apply_mask","page":"Reference","title":"TwoDimensional.apply_mask","text":"TwoDimensional.apply_mask(Aᵢₙ, args...; kwds...) -> Aₒᵤₜ\n\nmultiplies the values of the input 2-dimensional array Aᵢₙ by a mask defined by arguments args... and keywords kwds... and returns the resulting output array Aₒᵤₜ. The input array Aᵢₙ is left unmodified, method TwoDimensional.apply_mask! may be used for in-place operation. See TwoDimensional.forge_mask for how to define a mask.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.apply_mask!","page":"Reference","title":"TwoDimensional.apply_mask!","text":"TwoDimensional.apply_mask!(A, args...; kwds...) -> A\n\nmultiplies in-place the 2-dimensional array A by a mask defined by arguments args... and keywords kwds... and returns A. See TwoDimensional.apply_mask for an out-of-place version and for details.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.forge_mask","page":"Reference","title":"TwoDimensional.forge_mask","text":"TwoDimensional.forge_mask(A::AbstractMatrix, msk; kwds...)\nTwoDimensional.forge_mask(A::AbstractMatrix, objs...; kwds...)\n\nyield a 2-dimensional array with entries set to the transmission by the mask msk for an array-like A. The mask may also be specified by the list objs... of elementary mask objects. The coordinates of the mask are assumed to be given in fractional Cartesian indices for A.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.forge_mask!","page":"Reference","title":"TwoDimensional.forge_mask!","text":"TwoDimensional.forge_mask!(dst, [X, Y,] msk; kwds...) -> dst\nTwoDimensional.forge_mask!(dst, [X, Y,] elems...; kwds...) -> dst\n\nIn-place version of TwoDimensional.forge_mask, it overwrites the destination array dst with the mask and returns it. If coordinates X and Y along the axes of dst are not specified, (X, Y) = axes(dst) is assumed.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.grid_step","page":"Reference","title":"TwoDimensional.grid_step","text":"TwoDimensional.grid_step(x::AbstractVector) -> stp\n\nyields the step along a vector of coordinates, throwing an error if the increment between successive values of x is not positive or not uniform.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.interpolate","page":"Reference","title":"TwoDimensional.interpolate","text":"TwoDimensional.interpolate(a, b, f) -> x\n\nyields linearly interpolated value between a and b by a fraction f. If f is a dimensionless factor, then the result is:\n\nx = a + f*(b - a)\n\notherwise, e.g. if f has units, the result is:\n\nx = (oneunit(f) - f)*a + f*b\n\nIn any case, a and b are promoted to the same type.\n\nHence, if f is a real, then f = 0 yields a while f = 1 yields b.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.is_opaque","page":"Reference","title":"TwoDimensional.is_opaque","text":"TwoDimensional.is_opaque(msk)\n\nyields whether mask element msk is opaque.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.is_transparent","page":"Reference","title":"TwoDimensional.is_transparent","text":"TwoDimensional.is_transparent(msk)\n\nyields whether mask element msk is transparent.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.aperture","page":"Reference","title":"TwoDimensional.aperture","text":"TwoDimensional.aperture(obj)\n\nyields a transparent mask element of same shape as obj.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.obscuration","page":"Reference","title":"TwoDimensional.obscuration","text":"TwoDimensional.obscuration(obj)\n\nyields an opaque mask element of same shape as obj.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.rectangular_aperture","page":"Reference","title":"TwoDimensional.rectangular_aperture","text":"TwoDimensional.rectangular_aperture(args...; kwds...)\n\nyields an elementary mask object representing a rectangular aperture defined by given arguments args... and keywords kwds... and whose edges are aligned with the Cartesian axes. See TwoDimensional.Rectangle constructor for possible arguments and keywords. A rectangular aperture is a transparent rectangular mask.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.rectangular_obscuration","page":"Reference","title":"TwoDimensional.rectangular_obscuration","text":"TwoDimensional.rectangular_obscuration(args...; kwds...)\n\nyields an elementary mask object representing a rectangular obscuration defined by given arguments args... and keywords kwds... and whose edges are aligned with the Cartesian axes. See TwoDimensional.Rectangle constructor for possible arguments and keywords. A rectangular obscuration is an opaque rectangular mask.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.circular_aperture","page":"Reference","title":"TwoDimensional.circular_aperture","text":"TwoDimensional.circular_aperture(args...; kwds...)\n\nyields an elementary mask object representing a circular aperture defined by given arguments args... and keywords kwds.... See TwoDimensional.Circle constructor for possible arguments and keywords. A circular aperture is a transparent circular mask.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.circular_obscuration","page":"Reference","title":"TwoDimensional.circular_obscuration","text":"TwoDimensional.circular_obscuration(args...; kwds...)\n\nyields an elementary mask object representing a circular obscuration defined by given arguments args... and keywords kwds.... See TwoDimensional.Circle constructor for possible arguments and keywords. A circular obscuration is an opaque circular mask.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.polygonal_aperture","page":"Reference","title":"TwoDimensional.polygonal_aperture","text":"TwoDimensional.polygonal_aperture(args...; kwds...)\n\nyields an elementary mask object representing a polygonal aperture defined by given arguments args... and keywords kwds.... See TwoDimensional.Polygon constructor for possible arguments and keywords. A polygonal aperture is a transparent polygonal mask.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.polygonal_obscuration","page":"Reference","title":"TwoDimensional.polygonal_obscuration","text":"TwoDimensional.polygonal_obscuration(args...; kwds...)\n\nyields an elementary mask object representing a polygonal obscuration defined by given arguments args... and keywords kwds.... See TwoDimensional.Polygon constructor for possible arguments and keywords. A polygonal obscuration is an opaque polygonal mask.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Other-Public-Methods","page":"Reference","title":"Other Public Methods","text":"","category":"section"},{"location":"reference/#TwoDimensional.area","page":"Reference","title":"TwoDimensional.area","text":"TwoDimensional.area(obj)\n\nyields the area of the geometric object obj.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.center","page":"Reference","title":"TwoDimensional.center","text":"center(obj::GeometricObject) -> c::Point\n\nyields the central point of the geometric object obj. For a polygon, the center of gravity of the vertices is returned.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.radius","page":"Reference","title":"TwoDimensional.radius","text":"TwoDimensional.radius(obj::GeometricObject)\n\nyields the radius of the geometric object obj. The result is the radius of the smallest circle enclosing the object.\n\nFor circle-like and point-like objects with integer coordinate type, the radius is also integer. For all other geometric objects, the raius is floating-point.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.vertices","page":"Reference","title":"TwoDimensional.vertices","text":"TwoDimensional.vertices(obj)\n\nyields the vertices defining the vertex-based graphical object obj. The result is a tuple or a vector of points.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.floor-Tuple{Point}","page":"Reference","title":"Base.floor","text":"floor([T,] obj)\n\napplies the floor function to the coordinates of the vertices defining the vertex-based geometric object obj and returns an object of the same kind built with the resulting vertices. Optional argument T can be the type of the returned object or the type of the coordinates for the returned object.\n\nSee also: round, ceil.\n\nFor bounding-boxes, see also: interior, exterior.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.ceil-Tuple{Point}","page":"Reference","title":"Base.ceil","text":"ceil([T,] obj)\n\napplies the ceil function to the coordinates of the vertices defining the vertex-based geometric object obj and returns an object of the same kind built with the resulting vertices. Optional argument T can be the type of the returned object or the type of the coordinates for the returned object.\n\nSee also: round, floor.\n\nFor bounding-boxes, see also: interior, exterior.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.round-Tuple{Point}","page":"Reference","title":"Base.round","text":"round([T,] obj, [r::RoundingMode])\n\napplies the round function to the coordinates of the vertices defining the vertex-based geometric object obj and returns an object of the same kind built with the resulting vertices. Optional argument T can be the type of the returned object or the type of the coordinates for the returned object. Rounding mode may be specified by optional argument r, the default being the same as the round method for a scalar value.\n\nSee also: floor, ceil.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.vec-Tuple{Polygon{var\"#s1\", var\"#s2\"} where {var\"#s1\", var\"#s2\"<:(AbstractVector{T} where T)}}","page":"Reference","title":"Base.vec","text":"vec(poly::TwoDimensional.Polygon)\n\nyields a vector of the vertices of the polygon poly.\n\nCall collect(poly) to make an independent copy of the vector of vertices.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Internal-Methods-and-Types","page":"Reference","title":"Internal Methods and Types","text":"","category":"section"},{"location":"reference/#TwoDimensional.VertexBasedObject","page":"Reference","title":"TwoDimensional.VertexBasedObject","text":"TwoDimensional.VertexBasedObject{T}\n\nis the union of types of objects defined by their vertices and with coordinate type T.\n\nSee also TwoDimensional.apply.\n\n\n\n\n\n","category":"type"},{"location":"reference/#TwoDimensional.apply","page":"Reference","title":"TwoDimensional.apply","text":"TwoDimensional.apply(f, obj)\n\napplies function f to each part of geometric object obj and rebuild an object of the same kind with the result. Here f is supposed to be a function implementing an elementary geometric operation such as moving, scaling, etc. the geometric object obj.\n\nIf obj is a bounding-box, keyword, swap (default false) specifies whether to swap the first and last end-points of the box.\n\nSee also TwoDimensional.elements and TwoDimensional.VertexBasedObject.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.geometric_properties","page":"Reference","title":"TwoDimensional.geometric_properties","text":"TwoDimensional.geometric_properties(poly) -> prop\n\nyields a named tuple with the geometric properties of the polygon poly:\n\nprop.singular # `true` if successive polygon vertices are not distinct\nprop.convex   # `true` if polygon is convex\nprop.direct   # `true` if vertices are ordered with direct trigonometric\n              # orientation (anti-clockwise)\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.is_convex","page":"Reference","title":"TwoDimensional.is_convex","text":"TwoDimensional.is_convex(obj) -> bool\n\nyields whether the geometric object obj is convex.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.is_nothing","page":"Reference","title":"TwoDimensional.is_nothing","text":"TwoDimensional.is_nothing(x)\nTwoDimensional.is_nothing(x, y...)\n\nyield whether x is nothing and, if other arguments y... are specified, that all other y... are nothing.\n\nSee also TwoDimensional.is_nothing.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.is_something","page":"Reference","title":"TwoDimensional.is_something","text":"TwoDimensional.is_something(x)\nTwoDimensional.is_something(x, y...)\n\nyield whether x is not nothing and, if other arguments y... are specified, that none of the other y... is nothing.\n\nSee also TwoDimensional.is_nothing.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.elements","page":"Reference","title":"TwoDimensional.elements","text":"TwoDimensional.elements(obj::GeometricElement)\n\nyields the individual elements of elementary geometric obj from which it can be re-built without ambiguities. For example, for a point pnt:\n\nPoint(elements(pnt)...) === pnt\nPoint(elements(pnt)) === pnt\n\nboth hold.\n\nGeometrical objects that have homogeneous elements (see TwoDimensional.VertexBasedObject) extend the Base.Tuple method to return these elements, the Base.getindex method to directly index among these elements, and the TwoDimensional.apply method.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TwoDimensional.shape","page":"Reference","title":"TwoDimensional.shape","text":"TwoDimensional.shape(obj)\n\nyields the elementary geometric object defining the shape of obj. The result is obj itself if it is an elementary geometric object.\n\n\n\n\n\n","category":"function"},{"location":"points/#Points","page":"Points","title":"Points","text":"","category":"section"},{"location":"points/","page":"Points","title":"Points","text":"Any object whose type is derived from AbstractPoint{T} has 2-D coordinates: its abscissa and ordinate respectively named x and y. The parameter T is the type of the coordinates and can be retrieved by the eltype method.","category":"page"},{"location":"points/#Aliases","page":"Points","title":"Aliases","text":"","category":"section"},{"location":"points/","page":"Points","title":"Points","text":"Call:","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"using TwoDimensional: AbstractPoint2D, Point2D","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"instead of:","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"using TwoDimensional","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"to have Point2D, AbstractPoint2D provided as respective aliases to TwoDimensional.Point and TwoDimensional.AbstractPoint.","category":"page"},{"location":"points/#Construction","page":"Points","title":"Construction","text":"","category":"section"},{"location":"points/","page":"Points","title":"Points","text":"The most simple concrete type is Point{T} constructed by:","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"Point(x,y)","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"where (x,y) are the coordinates of the point.","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"Coordinates and weights can also be specified by keywords:","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"Point(x=xval, y=yval)","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"There are no default values for keywords x and y so they must both be specified.","category":"page"},{"location":"points/#Fields","page":"Points","title":"Fields","text":"","category":"section"},{"location":"points/","page":"Points","title":"Points","text":"The fields of a Point, say pnt, can be retrieved in different ways:","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"x = pnt.x\ny = pnt.y","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"or:","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"x = pnt[1]\ny = pnt[2]","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"or:","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"x, y = pnt","category":"page"},{"location":"points/#Conversion","page":"Points","title":"Conversion","text":"","category":"section"},{"location":"points/","page":"Points","title":"Points","text":"Simple points can be constructed from a 2-tuple of coordinates or from an instance of 2-dimensional CartesianIndex:","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"v = (x,y)\nI = CartesianIndex(x,y)\nPoint(v)    # yields Point(x,y)\nPoint(I)    # yields Point(x,y)","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"and reciprocally, assuming P = Point(x,y):","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"Tuple(P)          # yields the 2-tuple (P.x, P.y)\nCartesianIndex(P) # yields CartesianIndex(P.x, P.y)","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"Coordinate type conversion, say to type T, for a point P = Point(x,y) is done by:","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"Point{T}(P)\nconvert(Point{T}, P)\nT.(P)","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"The latter form involves broadcasting rules and may be a bit slower.","category":"page"},{"location":"points/#Operations-on-Points","page":"Points","title":"Operations on Points","text":"","category":"section"},{"location":"points/","page":"Points","title":"Points","text":"The addition (resp. subtraction) of two points adds (resp. subtracts) their coordinates:","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"Point(x1,y1) + Point(x2,y2)   # yields Point(x1+x2,y1+y2)\nPoint(x1,y1) - Point(x2,y2)   # yields Point(x1-x2,y1-y2)","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"Unary minus of a point negates its coordinates:","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"-Point(x,y)   # yields Point(-x,-y)","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"A point may be multiplied or divided by a scalar, say α, to scale its coordinates:","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"α*Point(x,y)  # yields Point(α*x,α*y)\nPoint(x,y)*α  # yields Point(α*x,α*y)\nα\\Point(x,y)  # yields Point((1/α)*x,(1/α)*y)\nPoint(x,y)/α  # yields Point((1/α)*x,(1/α)*y)","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"Taking the hypothenuse or the arctangent of a point P = Point(x,y) yield its distance to the origin O = Point(0,0) and the angle between OP and the abscissa axis:","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"hypot(Point(x,y))  # yields hypot(x, y)\natan(Point(x,y))   # yields atan(y, x)","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"The distance between two points is given by the distance method:","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"distance(Point(x1,y1),Point(x2,y2))  # yields hypot(x1-x2,y1-y2)","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"The nearest point to an instance obj of Point is given by:","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"round([T,] obj, [r::RoundingMode])","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"which rounds the coordinates of obj to the nearest integral value. Optional argument T is to specify the type of the result or the type of the coordinates of the result. Optional argument r is the rounding mode, the default is the same as round for a scalar value.","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"Similarly, floor([T,],P) and ceil([T,],P) yield the point with integer coordinates immediately (inclusively) before and after Point P.","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"A point can be clamped within the limits of a bounding-box:","category":"page"},{"location":"points/","page":"Points","title":"Points","text":"clamp(Point(-1.1, 6.3), BoundingBox(1:4,1:5)) # yields Point(1.0,5.0)","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"TwoDimensional is a [Julia][julia-url] package which provides useful types and methods to define and manipulate 2-dimensional objects (points, rectangles, circles, polygons, and bounding-boxes) and affine coordinate transforms. This package also offers methods to build masks from the composition of elementary shapes.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Other related packages:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"CoordinateTransformations for coordinate transformations;\nGeometryBasics for basic geometric types;\nGraphics for basic graphical objects and methods;","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The source code of TwoDimensional is available on GitHub.","category":"page"},{"location":"#Exported-Types","page":"Introduction","title":"Exported Types","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"using TwoDimensional","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"gives you types AffineTransform, Point, Rectangle, Circle, Polygon, and BoundingBox.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To avoid conflicts with other packages, you may specifically use/import aliases to these types with suffixes 2D like AffineTransform2D, Point2D, BoundingBox2D, etc. For example:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using TwoDimensional: AffineTransform2D, Point2D, Polygon2D, BoundingBox2D","category":"page"},{"location":"#Table-of-contents","page":"Introduction","title":"Table of contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"install.md\",\n    \"points.md\",\n    \"boxes.md\",\n    \"xforms.md\",\n    \"reference.md\",\n]","category":"page"},{"location":"#Index","page":"Introduction","title":"Index","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"}]
}
